package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"github.com/google/uuid"
	"gql-sub-demo/graph/model"
	"sync"
)

var mu sync.RWMutex
var messages []*model.Message
var subscribers = map[string]chan *model.Message{}

// PostMessage is the resolver for the postMessage field.
func (r *mutationResolver) PostMessage(ctx context.Context, user string, text string) (*model.Message, error) {
	mu.Lock()
	defer mu.Unlock()

	msg := &model.Message{
		ID:   uuid.NewString(),
		User: user,
		Text: text,
	}
	messages = append(messages, msg)

	// notify subscribers
	for _, ch := range subscribers {
		ch <- msg
	}
	return msg, nil
}

// Messages is the resolver for the messages field.
func (r *queryResolver) Messages(ctx context.Context) ([]*model.Message, error) {
	mu.RLock()
	defer mu.RUnlock()
	return messages, nil
}

// MessageAdded is the resolver for the messageAdded field.
func (r *subscriptionResolver) MessageAdded(ctx context.Context) (<-chan *model.Message, error) {
	mu.Lock()
	defer mu.Unlock()
	id := uuid.NewString()
	ch := make(chan *model.Message, 1)

	subscribers[id] = ch

	// Clean up when client disconnects
	go func() {
		<-ctx.Done()
		mu.Lock()
		defer mu.Unlock()
		delete(subscribers, id)
		close(ch)
	}()

	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
